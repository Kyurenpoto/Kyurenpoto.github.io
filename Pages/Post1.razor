@page "/post/1"

<MetaTags title="논문 리뷰: Implicit Neural Representations with Periodic Activation Functions - " description="논문 리뷰: Implicit Neural Representations with Periodic Activation Functions" route="/post/1" />

<h1>논문 리뷰: Implicit Neural Representations with Periodic Activation Functions</h1>

<p>논문 링크: <a href="https://arxiv.org/abs/2006.09661">https://arxiv.org/abs/2006.09661</a></p>
<p>논문의 초록, 서론, 결론을 종합하면 다음과 같다.</p>
<ol>
    <li>기존의 ReLU 기반 MLP는 입력 신호의 고차 미분을 나타낼 수 없기 때문에 미세 표현 능력이 부족하다.</li>
    <li>이를 개선하기 위해 주기 함수를 활성 함수로 사용해서 고차 미분 정보를 회손하지 않도록 했다.</li>
    <li>다양한 문제에서 기존 모델과 비교했을 때 더 나은 표현을 보임을 실험을 통해 증명했다.</li>
</ol>
<p>이 글에서는 논문의 요점을 간략하게 요약하고, 이에 관련된 여러 테마에 대한 몇 가지 discussion을 내 방식대로 진행한다.</p>

<hr />

<h2>요점 요약</h2>

<p>우리가 풀어야 하는 식은 다음과 같다.</p>
<p class="katex">
    <katex-expression expression='F\left(\mathbf{x},\Phi\left(\mathbf{x}\right),\nabla\Phi\left(\mathbf{x}\right),\cdots\right)=0' katex-options='{ "displayMode": true , "throwOnError": true }' />
</p>
<p>이걸 <katex-expression expression='M' katex-options='{ "displayMode": false , "throwOnError": true }' /> 개의 제약 조건에 대한 식으로 다음과 같이 바꿀 수 있다.</p>
<p class="katex">
    <katex-expression expression='C_m\left(\mathbf{a}\left(\mathbf{x}\right),\Phi\left(\mathbf{x}\right),\nabla\Phi\left(\mathbf{x}\right),\cdots\right)=0\qquad\left(\forall\mathbf{x}\in\Omega_m\quad m\in\left\lbrace 1,\cdots\,M\right\rbrace\right)' katex-options='{ "displayMode": true , "throwOnError": true }' />
</p>
<p>이 식은 다시 손실 함수로 변환할 수 있다.</p>
<p class="katex">
    <katex-expression expression='L=\int_{\Omega}\sum_{m=1}^{M}1_{\Omega_m}\left(\mathbf{x}\right)\left\|C_m\left(\mathbf{a}\left(\mathbf{x}\right),\Phi\left(\mathbf{x}\right),\nabla\Phi\left(\mathbf{x}\right),\cdots\right)\right\|d\mathbf{x}\qquad\left(1_{\Omega_m}\left(\mathbf{x}\right)=\begin{cases}1 & \mathbf{x}\in\Omega_m\\0 & \mathbf{x}\notin\Omega_m\end{cases}\right)' katex-options='{ "displayMode": true , "throwOnError": true }' />
</p>
<p>손실 함수는 <katex-expression expression='\Phi\left(\mathbf{x}\right)' katex-options='{ "displayMode": false , "throwOnError": true }' /> 의 정의역에서 샘플링해서 추정한다. 데이터 셋은 실행 중 동적으로 추출하며, <katex-expression expression='\left\lbrace\left(\mathbf{x}_i,\mathbf{a}_i\left(\mathbf{x}\right)\right)\right\rbrace_i\;\left(\mathbf{x}_i\in\Omega\right)' katex-options='{ "displayMode": false , "throwOnError": true }' /> 의 형태로 주어진다. 따라서 Loss는 다음과 같다.</p>
<p class="katex">
    <katex-expression expression='\bar{L}=\sum_{i\in D}\sum_{m=1}^{M}\left\|C_m\left(a\left(\mathbf{x}_i\right),\Phi\left(\mathbf{x}_i\right),\nabla\Phi\left(\mathbf{x}_i\right),\cdots\right)\right\|' katex-options='{ "displayMode": true , "throwOnError": true }' />
</p>

<hr />

<h3>SIREN 활성함수</h3>

<p>논문에서 제안하는 SIREN 활성함수는 다음과 같다.</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
    <mrow>
        <mo>&Phi;</mo>
        <mrow>
            <mo>(</mo>
            <mi mathvariant="bold">x</mi>
            <mo>)</mo>
        </mrow>
        <mo>=</mo>
        <msub>
            <mi mathvariant="bold">M</mi>
            <mi>n</mi>
        </msub>
        <mrow>
            <mo>(</mo>
            <msub>
                <mo>&phi;</mo>
                <mrow>
                    <mi>n</mi>
                    <mo>-</mo>
                    <mn>1</mn>
                </mrow>
            </msub>
            <mo>&compfn;</mo>
            <msub>
                <mo>&phi;</mo>
                <mrow>
                    <mi>n</mi>
                    <mo>-</mo>
                    <mn>2</mn>
                </mrow>
            </msub>
            <mo>&compfn;</mo>
            <mo>&ctdot;</mo>
            <mo>&compfn;</mo>
            <msub>
                <mo>&phi;</mo>
                <mn>0</mn>
            </msub>
            <mo>)</mo>
        </mrow>
        <mrow>
            <mo>(</mo>
            <mi mathvariant="bold">x</mi>
            <mo>)</mo>
        </mrow>
        <mo>+</mo>
        <msub>
            <mi mathvariant="bold">b</mi>
            <mi>n</mi>
        </msub>
        <mspace width="1em" />
        <mrow>
            <mo>(</mo>
            <msub>
                <mo>&phi;</mo>
                <mi>i</mi>
            </msub>
            <mrow>
                <mo>(</mo>
                <msub>
                    <mi mathvariant="bold">x</mi>
                    <mi>i</mi>
                </msub>
                <mo>)</mo>
            </mrow>
            <mo>=</mo>
            <mi mathvarint="normal">sin</mi>
            <mrow>
                <mo>(</mo>
                <msub>
                    <mi mathvariant="bold">W</mi>
                    <mi>i</mi>
                </msub>
                <msub>
                    <mi mathvariant="bold">x</mi>
                    <mi>i</mi>
                </msub>
                <mo>+</mo>
                <msub>
                    <mi mathvariant="bold">b</mi>
                    <mi>i</mi>
                </msub>
                <mo>)</mo>
            </mrow>
            <mo>)</mo>
        </mrow>
    </mrow>
</math>
<p>여기서 <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
    <mrow>
        <mi>i</mi>
    </mrow>
</math> 는 몇 번째 레이어인지를 나타낸다. 이렇게 정의된 SIREN을 미분하면 또 SIREN이 된다. SIREN의 미분은 SIREN의 특성을 상속하므로, 고차 미분을 통해 복잡한 신호의 특성을 분석할 수 있다.</p>

<hr />

<h3>SIREN 초기화</h3>

<p>논문에서는 SIREN의 효과적인 학습에 필요한 초기화 원칙도 제시한다. 핵심 아이디어는 네트워크를 통한 활성화 분포를 유지해서, 초기화시 최종 출력이 레이어 수에 의존하지 않도록 하는 것이다. 균일하게 분산된 가중치를 신중하게 선택하지 않으면 정확도와 수렴 속도 모두에서 성능이 저하된다.</p>
<p>먼저 균등 분포 상의 입력 <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
    <mrow>
        <mi>x</mi>
        <mo>&sim;</mo>
        <mi>U</mi>
        <mrow>
            <mo>(</mo>
            <mn>-1</mn>
            <mo>,</mo>
            <mn>1</mn>
            <mo>)</mo>
        </mrow>
    </mrow>
</math> 를 가진 단일 사인 뉴런의 출력 분포를 고려한다. 뉴런의 출력은 <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
    <mrow>
        <mi mathvariant="normal">sin</mi>
        <mrow>
            <mo>(</mo>
            <mi>a</mi>
            <mi>x</mi>
            <mo>+</mo>
            <mi>b</mi>
            <mo>)</mo>
        </mrow>
        <mspace width="1em" />
        <mrow>
            <mo>(</mo>
            <mi>a</mi>
            <mo>,</mo>
            <mi>b</mi>
            <mo>&isin;</mo>
            <mi mathvariant="double-struck">R</mi>
            <mo>)</mo>
        </mrow>
    </mrow>
</math> 이다. 임의의 <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
    <mrow>
        <mi>a</mi>
        <mo>&gt;</mo>
        <mfrac>
            <mo>&pi;</mo>
            <mn>2</mn>
        </mfrac>
        <mo></mo>
    </mrow>
</math> 에 대해 사인 함수의 출력의 분포는 <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
    <mrow>
        <mi>y</mi>
        <mo>&sim;</mo>
        <mi mathvariant="normal">arcsin</mi>
        <mrow>
            <mo>(</mo>
            <mn>-1</mn>
            <mo>,</mo>
            <mn>1</mn>
            <mo>)</mo>
        </mrow>
    </mrow>
</math> 이다. 이것은 U자형 베타 분포의 특별한 경우이며, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
    <mrow>
        <mi>b</mi>
    </mrow>
</math> 와는 무관하다.</p>
<p>이를 통해 뉴런의 출력 분포에 대해 추론할 수 있다. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
    <mrow>
        <msup>
            <mi mathvariant="double-struck">R</mi>
            <mi>n</mi>
        </msup>
    </mrow>
</math> 상의 가중치 <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
    <mrow>
        <mi mathvariant="bold">n</mi>
    </mrow>
</math> 와 <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
    <mrow>
        <msup>
            <mi mathvariant="double-struck">R</mi>
            <mi>n</mi>
        </msup>
    </mrow>
</math> 상의 입력 <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
    <mrow>
        <mi mathvariant="bold">x</mi>
    </mrow>
</math> 의 선형 조합을 취하면, 출력은 <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
    <mrow>
        <mi>y</mi>
        <mo>=</mo>
        <mi mathvariant="normal">sin</mi>
        <mrow>
            <mo>(</mo>
            <msup>
                <mi mathvariant="bold">w</mi>
                <mi>T</mi>
            </msup>
            <mi mathvariant="bold">x</mi>
            <mo>+</mo>
            <mi mathvariant="bold">b</mi>
            <mo>)</mo>
        </mrow>
    </mrow>
</math> 이다. 이 뉴런이 두 번째 층에 있다고 가정하면, 각 입력은 <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
    <mrow>
        <mi mathvariant="normal">arcsin</mi>
    </mrow>
</math> 분포이다. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
    <mrow>
        <mi mathvariant="bold">w</mi>
    </mrow>
</math> 의 각 성분이 <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
    <mrow>
        <msub>
            <mi>w</mi>
            <mi>i</mi>
        </msub>
        <mo>&sim;</mo>
        <mi>U</mi>
        <mrow>
            <mo>(</mo>
            <mo>-</mo>
            <mi>c</mi>
            <mo>/</mo>
            <msqrt>
                <mi>n</mi>
            </msqrt>
            <mo>,</mo>
            <mi>c</mi>
            <mo>/</mo>
            <msqrt>
                <mi>n</mi>
            </msqrt>
            <mo>)</mo>
        </mrow>
        <mspace width="1em" />
        <mrow>
            <mo>(</mo>
            <mi>c</mi>
            <mo>&isin;</mo>
            <mi mathvariant="double-struck">R</mi>
            <mo>)</mo>
        </mrow>
    </mrow>
</math> 로 균일하게 분포할 때, 논문에서는 <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
    <mrow>
        <mi>n</mi>
    </mrow>
</math> 이 커질수록 내적이 정규 분포 <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
    <mrow>
        <mi>N</mi>
        <mrow>
            <mo>(</mo>
            <mn>0</mn>
            <mo>,</mo>
            <msup>
                <mi>c</mi>
                <mn>2</mn>
            </msup>
            <mo>/</mo>
            <mn>6</mn>
            <mo>)</mo>
        </mrow>
    </mrow>
</math> 에 수렴함을 보였다. 이 정규분포 위의 내적을 다른 사인 함수에 먹이면 모든 <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
    <mrow>
        <mi>c</mi>
        <mo>&gt;</mo>
        <msqrt>
            <mn>6</mn>
        </msqrt>
    </mrow>
</math> 에 대해 <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
    <mrow>
        <mi mathvariant="normal">arcsin</mi>
    </mrow>
</math> 분포하게 된다. SIREN의 가중치는 각도 주파수로 해석될 수 있으며, 편향은 위상 오프셋이다. 따라서 네트워크에서 큰 주파수는 큰 가중치에 대해 나타난다. 사인 레이어는 내적의 절대값이 <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
    <mrow>
        <mo>&pi;</mo>
    </mrow>
</math> 보다 작은 경우 주파수를 거의 변경하지 않는다. 절대값이 더 커지면 주파수가 증가한다.</p>
<p>이를 종합해서 논문은 <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
    <mrow>
        <mi>c</mi>
        <mo>=</mo>
        <mn>6</mn>
    </mrow>
</math> 으로 두고 <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
    <mrow>
        <msub>
            <mi>w</mi>
            <mi>i</mi>
        </msub>
        <mo>&sim;</mo>
        <mi>U</mi>
        <mrow>
            <mo>(</mo>
            <mo>-</mo>
            <msqrt>
                <mn>6</mn>
                <mo>/</mo>
                <mi>n</mi>
            </msqrt>
            <mo>,</mo>
            <msqrt>
                <mn>6</mn>
                <mo>/</mo>
                <mi>n</mi>
            </msqrt>
            <mo>)</mo>
        </mrow>
    </mrow>
</math> 로 분포시키는 것을 제안한다. 이는 각 사인 활성함수의 입력이 표준편차 1인 정규분포를 유지하도록 한다. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
    <mrow>
        <mo>&pi;</mo>
    </mrow>
</math> 보다 더 큰 가중치는 거의 없으므로, 사인 네트워크 전체의 주파수는 느리고 강건하게 증가한다. 또한 사인 함수가 <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
    <mrow>
        <mo>[</mo>
        <mn>-1</mn>
        <mo>,</mo>
        <mn>1</mn>
        <mo>]</mo>
    </mrow>
</math> 를 넘어 여러 주기에 걸쳐 있도록 사인 네트워크의 첫 번째 레이어를 가중치 <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
    <mrow>
        <msub>
            <mo>&omega;</mo>
            <mn>0</mn>
        </msub>
        <mo>=</mo>
        <mn>30</mn>
    </mrow>
</math> 으로 초기화할 것을 제안한다. 이 값은 여러 실험을 통해 도출해낸 값이다. 이 초기화 방식에 의해 논문에서 행한 모든 실험에서 ADAM Optimizer를 사용한 빠르고 강건한 수렴이 나타난다.</p>

<h2>weight/bias 정규화</h2>

<p>사인 함수를 사용하면 그래디언트가 증발하거나 폭발하는 문제가 거의 없다. 사인 함수의 치역에 특정 균등 분포에서 추출한 값을 곱한 값이 (-pi, pi)를 거의 벗어나지 않는 표준 정규 분포를 이루기 때문이다. 저 범위를 벗어나는 경우 그래디언트를 조작해서 저 범위 안쪽으로 끌고 오면 그만이다.</p>
<p>다만 초반 레이어의 경우 입력 값의 분포에 따라 정규 분포의 모양이 달라지므로, 해당 레이어의 선형 연산의 결과가 표준 정규분포를 이루도록 weight/bias 를 조정할 필요가 있다.</p>
<p>개인적으로는 이렇게 해도 activation function 을 사인 함수로 통일할 수는 없다고 생각한다. 입력값이 특정 범위로 정규화된 경우에는 큰 문제가 없지만(푸리에 해석 참고), 입력값이 각 좌표축에서 어느 한쪽이라도 발산이 일어난다면 주기함수와 선형함수만으로는 정규화가 불가능하기 때문이다.</p>
<p>따라서 주기성과 선형성을 가지지 않는 연속인 비선형 일대일 대응 함수(Sigmoid, tanh)가 필요하다. 물론 이 경우 그래디언트가 증발하는 문제점이 있지만, 앞부분에만 적용하는 정도라면 증발을 걱정할 이유가 없다.</p>
<p>즉, 앞 부분에는 Sigmoid 또는 tanh를 적용하고 그 뒤부터는 sin을 사용하면 대부분의 문제가 해결된다고 볼 수 있다.</p>

<h2>Skip Connection, Bottleneck Architecture, Attention Method</h2>

<p>기존의 방법론에서는 Activation Function 들이 가지는 그래디언트 관련 문제 때문에 Skip Connection 이 도입되었다. 앞 단계의 레이어에서 output을 가져와서 사용하면 그래디언트 관련 문제를 완화하는 동시에 해당 그래디언트 정보를 뒷 단계의 레이어에서 활용할 수 있다.</p>
<p>다만 Skip Conection 은 서로 연결할 레이어들의 output shape 를 강제하며, 추가적인 연산 비용이 든다. 이는 더 큰 모델이 나올수록 기하급수적으로 많은 계산 성능이 필요한 원인이 된다.</p>
<p>Skip Connection 대신 SIREN 을 이용하면 ODE/PDE 정보를 활용하면서 계산량을 줄일 수 있을 것이다.</p>

<p>작성중..</p>
